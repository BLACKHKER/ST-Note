#### 	ResponseResult(封装统一结果集，配合ResponseState)

##### ResponseResult：

```java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;

import java.io.Serializable;

/**
 * @Author BLACKHKER
 * @Date 2023/7/11 16:01
 * @ClassName: ResponseResult
 * @Description: 封装统一结果集
 * @Version 1.0
 *
 * http状态码
 *  200     成功
 *  404     资源未找到     url匹配不上
 *  500     后台代码错误
 *  503     网关错误
 *  504
 *  400     前端提交的数据无法转换为后端形参的类型
 *  403     未认证（登录）
 *  401     没权限
 *  405     请求方式不对
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Accessors(chain = true)   // 链式表达
public class ResponseResult<T> implements Serializable {
    private int code;               // 状态码，参考http的状态码
    private ResponseState state;    // 状态
    private String message;         // 提示
    private T data;                 // 泛型
}

```

##### ResponseState：

```java
/**
 * @Author BLACKHKER
 * @Date 2023/7/11 16:20
 * @ClassName: ResponseState
 * @Description: 封装统一结果集，状态枚举
 * @Version 1.0
 */
public enum ResponseState {
    LOGIN_SUCCESS,
    LOGIN_FAIL,
    NO_LOGIN,
    REGISTER_SUCCESS,
    REGISTER_FAIL,
    ADD_SUCCESS,
    ADD_FAIL,
    DEL_SUCCESS,
    DEL_FAIL,
    UPDATE_SUCCESS,
    UPDATE_FAIL,
    SELECT_SUCCESS,
    SELECT_FAIL,
    NO_PERMS
}
```





#### JWTUtil(配合TokenEnum)

##### JWTUtil：

```java
import java.util.Date;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.TokenExpiredException;

/**
 * @Author BLACKHKER
 * @Date 2023/7/11 17:23
 * @ClassName: Aaa
 * @Description: JWT验证
 * @Version 1.0
 */
public class JWTUtil {
    public static final String SECRET_KEY = "123456"; // 秘钥
    public static final long TOKEN_EXPIRE_TIME = 365 * 24 * 60 * 60 * 1000; // token过期时间
    public static final long REFRESH_TOKEN_EXPIRE_TIME = 10 * 60 * 1000; // refreshToken过期时间
    private static final String ISSUER = "issuer"; // 签发人

    /**
     * 生成签名
     */
    public static String generateToken(int uid){
        Date now = new Date();
        //创建签名算法对象
        Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY); // 算法

        String token = JWT.create()
                .withIssuer(ISSUER) // 签发人
                .withIssuedAt(now)  // 签发时间
                .withExpiresAt(new Date(now.getTime() + TOKEN_EXPIRE_TIME)) // 过期时间
                .withClaim("uid", uid) // 保存身份标识
                .sign(algorithm);
        return token;
    }

    /**
     * 验证token
     */
    public static TokenEnum verify(String token){
        try {
            // 签名算法
            Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY); // 算法
            JWTVerifier verifier = JWT.require(algorithm)
                    .withIssuer(ISSUER)
                    .build();
            verifier.verify(token);
            return TokenEnum.TOKEN_SUCCESS;
        } catch (TokenExpiredException ex){
            return TokenEnum.TOKEN_EXPIRE;
            //ex.printStackTrace();
        } catch (Exception e) {
            return TokenEnum.TOKEN_BAD;
        }
    }

    /**
     * 从token获取uid
     */
    public static int getuid(String token){
        try{
            return JWT.decode(token).getClaim("uid").asInt();
        }catch(Exception ex){
            ex.printStackTrace();
        }
        return 0;
    }
}
```



##### TokenEnum：

```java
/**
 * @Author BLACKHKER
 * @Date 2023/8/2 14:49
 * @ClassName: TokenEnum
 * @Description: Token枚举类
 * @Version 1.0
 */
public enum TokenEnum {
    TOKEN_EXPIRE,TOKEN_BAD,TOKEN_SUCCESS
}
```



